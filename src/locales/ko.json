{
  "common": {
    "loading": "로딩 중...",
    "error": "오류",
    "success": "성공",
    "cancel": "취소",
    "save": "저장",
    "delete": "삭제",
    "edit": "편집",
    "create": "생성",
    "search": "검색",
    "submit": "제출",
    "refresh": "새로고침",
    "close": "닫기",
    "confirm": "확인",
    "back": "뒤로",
    "next": "다음",
    "previous": "이전",
    "yes": "예",
    "no": "아니오"
  },
  "nav": {
    "home": "홈",
    "dashboard": "대시보드",
    "settings": "설정",
    "profile": "프로필",
    "logout": "로그아웃",
    "login": "로그인",
    "mswTest": "MSW 테스트",
    "zustandTest": "Zustand 테스트"
  },
  "pages": {
    "home": {
      "title": "환영합니다",
      "description": "TanStack Router로 구축된 현대적인 React 애플리케이션입니다",
      "getStarted": "시작하기"
    },
    "mswTest": {
      "title": "MSW + TanStack Query 테스트",
      "description": "FastAPI 스타일의 모킹된 백엔드 API를 TanStack Query로 테스트해보세요",
      "devToolsHint": "React Query DevTools를 열어서 캐싱과 상태를 확인해보세요!",
      "healthCheck": {
        "title": "1. Health Check",
        "button": "상태 확인",
        "loading": "로딩 중..."
      },
      "itemsList": {
        "title": "2. Items List (GET /api/items)",
        "fetchButton": "아이템 불러오기",
        "loading": "로딩 중...",
        "total": "총: {{count}}개 아이템 (캐시된 데이터)",
        "delete": "삭제",
        "deleting": "삭제 중..."
      },
      "createItem": {
        "title": "3. Create Item (POST /api/items)",
        "nameLabel": "이름",
        "namePlaceholder": "상품명",
        "descriptionLabel": "설명",
        "descriptionPlaceholder": "상품 설명",
        "priceLabel": "가격",
        "pricePlaceholder": "가격",
        "button": "아이템 생성",
        "creating": "생성 중...",
        "success": "아이템이 성공적으로 생성되었습니다! (자동으로 리스트가 새로고침됩니다)",
        "allFieldsRequired": "모든 필드를 입력해주세요"
      },
      "usersList": {
        "title": "4. Users List (GET /api/users)",
        "fetchButton": "사용자 불러오기",
        "loading": "로딩 중...",
        "total": "총: {{count}}명 사용자",
        "active": "활성",
        "inactive": "비활성"
      },
      "login": {
        "title": "5. Login (POST /api/auth/login)",
        "usernameLabel": "사용자명",
        "passwordLabel": "비밀번호",
        "button": "로그인",
        "loggingIn": "로그인 중...",
        "hint": "힌트: username=admin, password=admin",
        "success": "로그인 성공! 토큰이 localStorage에 저장되었습니다"
      },
      "search": {
        "title": "6. Search (GET /api/search?q=query)",
        "placeholder": "아이템 검색...",
        "button": "검색",
        "searching": "검색 중...",
        "results": "\"{{query}}\"에 대한 {{count}}개 결과를 찾았습니다"
      },
      "benefits": {
        "title": "TanStack Query 장점",
        "caching": "자동 캐싱: 데이터가 자동으로 캐시되어 불필요한 API 호출을 줄입니다",
        "refresh": "자동 새로고침: Mutation 후 관련 쿼리가 자동으로 무효화됩니다",
        "states": "로딩/에러 상태: isLoading, isError, isPending이 자동 관리됩니다",
        "devtools": "DevTools: React Query DevTools로 상태를 실시간 확인할 수 있습니다",
        "switching": "백엔드 전환: .env 파일의 VITE_API_MODE를 'real'로 변경하면 실제 백엔드로 전환됩니다"
      }
    },
    "zustandTest": {
      "title": "Zustand 상태 관리 테스트",
      "description": "모든 스토어 슬라이스의 대화형 데모: API 데이터, UI 상태, 작업 관리, 작업 전파.",
      "apiSection": {
        "title": "API Slice (데이터 관리)",
        "fetchUsers": "사용자 불러오기",
        "loading": "로딩 중...",
        "addNewUser": "새 사용자 추가",
        "namePlaceholder": "이름",
        "emailPlaceholder": "이메일",
        "add": "추가",
        "usersCount": "사용자 ({{count}})",
        "noUsers": "사용자가 없습니다. \"사용자 불러오기\"를 클릭하세요.",
        "remove": "제거"
      },
      "uiSection": {
        "title": "UI Slice (UI 상태)",
        "themeControl": "테마 제어",
        "sidebarControl": "사이드바 제어",
        "sidebarIs": "사이드바: {{state}}",
        "open": "열림",
        "closed": "닫힘",
        "language": "언어",
        "modal": "모달",
        "openModal": "모달 열기",
        "modalTitle": "테스트 모달",
        "modalContent": "이것은 Zustand 스토어의 모달 콘텐츠입니다!",
        "notifications": "알림",
        "info": "정보",
        "success": "성공",
        "warning": "경고",
        "error": "오류",
        "infoNotification": "정보 알림",
        "successNotification": "성공 알림",
        "warningNotification": "경고 알림",
        "errorNotification": "오류 알림"
      },
      "taskSection": {
        "title": "Task Slice (작업 관리)",
        "filter": "필터",
        "all": "전체",
        "pending": "대기 중",
        "inProgress": "진행 중",
        "completed": "완료됨",
        "cancelled": "취소됨",
        "sortBy": "정렬 기준",
        "created": "생성일",
        "dueDate": "마감일",
        "priority": "우선순위",
        "addNewTask": "새 작업 추가",
        "taskTitlePlaceholder": "작업 제목",
        "low": "낮음",
        "medium": "보통",
        "high": "높음",
        "addTask": "작업 추가",
        "tasksCount": "작업 ({{count}})",
        "noTasks": "작업이 없습니다. 위에서 추가하세요!",
        "taskDescription": "Zustand 테스트 페이지에서 생성된 작업"
      },
      "workSection": {
        "title": "작업 전파 (Props Drilling 없음)",
        "description": "각 레벨에서 상태를 구독하는 깊은 컴포넌트 계층 - props drilling 없음!",
        "level0": {
          "title": "Level 0: 워크플로우 제어",
          "subscribesTo": "구독:",
          "workNamePlaceholder": "작업 이름 입력",
          "simulateWork": "작업 시뮬레이션",
          "working": "작업 중...",
          "cancelWork": "작업 취소",
          "clearHistory": "기록 지우기",
          "clearLogs": "로그 지우기"
        },
        "level1": {
          "title": "Level 1: 현재 작업 상태",
          "subscribesTo": "구독:",
          "propsReceived": "받은 Props:",
          "none": "없음",
          "status": "상태:",
          "progress": "진행률",
          "noWorkInProgress": "진행 중인 작업 없음"
        },
        "level2": {
          "title": "Level 2: 최근 로그",
          "subscribesTo": "구독:",
          "propsReceived": "받은 Props:",
          "none": "없음",
          "noLogs": "아직 로그가 없습니다"
        },
        "level3": {
          "title": "Level 3: 기록 개수",
          "subscribesTo": "구독:",
          "propsReceived": "받은 Props:",
          "none": "없음",
          "completedWorks": "완료된 작업"
        },
        "level4": {
          "title": "Level 4: 최하위 컴포넌트",
          "subscribesTo": "구독:",
          "propsReceived": "받은 Props:",
          "none": "없음",
          "systemActive": "시스템 활성",
          "systemIdle": "시스템 유휴"
        },
        "liveLogs": "실시간 로그 ({{count}})",
        "noLogsYet": "아직 로그가 없습니다",
        "workHistory": "작업 기록 ({{count}})",
        "duration": "소요시간: {{time}}초"
      }
    },
    "notFound": {
      "title": "페이지를 찾을 수 없습니다",
      "description": "요청하신 페이지가 존재하지 않습니다",
      "goHome": "홈으로 이동"
    }
  },
  "messages": {
    "itemCreated": "아이템이 성공적으로 생성되었습니다",
    "itemUpdated": "아이템이 성공적으로 업데이트되었습니다",
    "itemDeleted": "아이템이 성공적으로 삭제되었습니다",
    "userCreated": "사용자가 성공적으로 생성되었습니다",
    "loginSuccess": "로그인 성공",
    "loginFailed": "로그인 실패",
    "networkError": "네트워크 오류. 다시 시도해 주세요.",
    "validationError": "입력 내용을 확인해 주세요",
    "confirmDelete": "이 항목을 삭제하시겠습니까?"
  },
  "form": {
    "name": "이름",
    "email": "이메일",
    "password": "비밀번호",
    "description": "설명",
    "price": "가격",
    "category": "카테고리",
    "required": "필수 입력 항목입니다",
    "invalidEmail": "유효하지 않은 이메일 주소입니다",
    "minLength": "최소 {{min}}자 이상이어야 합니다",
    "maxLength": "최대 {{max}}자까지 입력 가능합니다"
  },
  "theme": {
    "light": "라이트",
    "dark": "다크",
    "system": "시스템"
  },
  "language": {
    "select": "언어 선택",
    "en": "영어",
    "ko": "한국어",
    "ja": "일본어"
  },
  "plurals": {
    "item_one": "{{count}}개 아이템",
    "item_other": "{{count}}개 아이템",
    "user_one": "{{count}}명 사용자",
    "user_other": "{{count}}명 사용자",
    "task_one": "{{count}}개 작업",
    "task_other": "{{count}}개 작업",
    "result_one": "{{count}}개 결과를 찾았습니다",
    "result_other": "{{count}}개 결과를 찾았습니다",
    "minute_one": "{{count}}분",
    "minute_other": "{{count}}분",
    "hour_one": "{{count}}시간",
    "hour_other": "{{count}}시간",
    "day_one": "{{count}}일",
    "day_other": "{{count}}일"
  },
  "format": {
    "dateShort": "{{date, dateShort}}",
    "dateLong": "{{date, dateLong}}",
    "time": "{{date, time}}",
    "dateTime": "{{date, dateTime}}",
    "relativeTime": "{{date, relativeTime}}",
    "number": "{{value, number}}",
    "currency": "{{value, currency}}",
    "percent": "{{value, percent}}"
  },
  "course": {
    "main": {
      "title": "게임 개발의 구조",
      "description": "3계층으로 이해하는 게임 개발",
      "center": {
        "title": "게임 개발",
        "description": "3계층 지식 구조"
      }
    },
    "demos": {
      "marioJump": {
        "title": "슈퍼마리오 점프 구현",
        "description": "Phaser 엔진으로 다양한 점프 메커니즘을 직접 체험해보세요"
      },
      "lockstep": {
        "title": "락스텝 동기화 데모",
        "description": "스타크래프트 스타일의 결정론적 동기화를 직접 체험해보세요"
      }
    },
    "layers": {
      "cases": {
        "title": "사례로 배우기",
        "description": "실제 게임들이 어떻게 구현했는지",
        "center": {
          "title": "사례 연구",
          "description": "게임을 선택하세요"
        }
      },
      "fundamentals": {
        "title": "기본 원리",
        "description": "게임 장르 무관하게 항상 필요한 불변 법칙",
        "center": {
          "title": "핵심 원리",
          "description": "주제를 선택하세요"
        }
      },
      "decisions": {
        "title": "설계 결정",
        "description": "게임 특성에 따라 달라지는 트레이드오프",
        "center": {
          "title": "설계 선택지",
          "description": "주제를 선택하세요"
        }
      }
    },
    "cases": {
      "cases-center": {
        "title": "사례 연구",
        "description": "게임을 선택하세요"
      },
      "super-mario": {
        "title": "슈퍼마리오",
        "description": "플랫포머의 정석, 정밀한 물리와 타이밍",
        "genre": "플랫포머",
        "year": "1985",
        "keyFeatures": ["정밀한 점프 물리", "타이밍 기반 게임플레이", "레벨 디자인"],
        "fundamentals": ["물리 연산", "렌더링"],
        "decisions": ["틱레이트"]
      },
      "maplestory": {
        "title": "메이플스토리",
        "description": "2D MMORPG, 대규모 동시접속 처리",
        "genre": "2D MMORPG",
        "year": "2003",
        "keyFeatures": ["대규모 동시접속", "실시간 전투", "경제 시스템"],
        "fundamentals": ["네트워크 통신", "직렬화", "모델링"],
        "decisions": ["멀티플레이 아키텍처", "동기화 전략"]
      },
      "overwatch": {
        "title": "오버워치",
        "description": "FPS, 클라이언트 예측과 서버 권한",
        "genre": "FPS",
        "year": "2016",
        "keyFeatures": ["클라이언트 예측", "서버 권한", "Favor the Shooter"],
        "fundamentals": ["네트워크 통신", "물리 연산"],
        "decisions": ["물리 처리 방식", "동기화 전략", "틱레이트"]
      },
      "pubg": {
        "title": "배틀그라운드",
        "description": "배틀로얄, 대규모 맵과 100인 동기화",
        "genre": "배틀로얄",
        "year": "2017",
        "keyFeatures": ["100인 동기화", "대규모 맵", "동적 안전구역"],
        "fundamentals": ["네트워크 통신", "모델링"],
        "decisions": ["멀티플레이 아키텍처", "물리 처리 방식"]
      },
      "lol": {
        "title": "리그 오브 레전드",
        "description": "MOBA, 결정론적 시뮬레이션",
        "genre": "MOBA",
        "year": "2009",
        "keyFeatures": ["결정론적 시뮬레이션", "락스텝", "리플레이 시스템"],
        "fundamentals": ["모델링", "네트워크 통신"],
        "decisions": ["동기화 전략", "틱레이트", "밸런싱"]
      },
      "starcraft": {
        "title": "스타크래프트",
        "description": "RTS, 락스텝과 완벽한 동기화",
        "genre": "RTS",
        "year": "1998",
        "keyFeatures": ["완벽한 동기화", "락스텝 네트워킹", "리플레이"],
        "fundamentals": ["모델링", "네트워크 통신"],
        "decisions": ["동기화 전략", "틱레이트"]
      },
      "candy-crush": {
        "title": "캔디크러쉬",
        "description": "3매치 퍼즐, 연쇄 반응 처리",
        "genre": "퍼즐",
        "year": "2012",
        "keyFeatures": ["3매치 알고리즘", "연쇄 반응", "특수 캔디 생성"],
        "fundamentals": ["모델링", "렌더링"],
        "decisions": ["밸런싱"]
      },
      "fortnite": {
        "title": "포트나이트",
        "description": "배틀로얄, Replication Graph와 대규모 동기화",
        "genre": "배틀로얄 / 빌딩",
        "year": "2017",
        "keyFeatures": ["100인 동기화", "Replication Graph", "20→30Hz 틱레이트 진화", "클라이언트 예측"],
        "fundamentals": ["네트워크 통신", "모델링", "직렬화"],
        "decisions": ["멀티플레이 아키텍처", "틱레이트", "동기화 전략"]
      },
      "counter-strike": {
        "title": "카운터스트라이크",
        "description": "경쟁 FPS, 정밀한 히트 판정과 틱레이트",
        "genre": "택티컬 FPS",
        "year": "2012 (CS:GO) / 2023 (CS2)",
        "keyFeatures": ["64Hz vs 128Hz 틱레이트", "서브틱 시스템 (CS2)", "Peeker's Advantage", "Lag Compensation"],
        "fundamentals": ["네트워크 통신", "물리 연산"],
        "decisions": ["틱레이트", "동기화 전략", "물리 처리 방식"]
      }
    },
    "fundamentals": {
      "fundamentals-center": {
        "title": "핵심 원리",
        "description": "주제를 선택하세요"
      },
      "modeling-simulation": {
        "title": "모델링 & 시뮬레이션",
        "description": "게임 세계의 상태 정의와 업데이트. 특히 멀티플레이어 게임에서는 모든 클라이언트가 동일한 시뮬레이션 결과를 얻어야 하는 결정론적 시뮬레이션이 핵심입니다.",
        "concepts": ["게임 루프", "상태 머신", "ECS 패턴", "월드 업데이트", "결정론적 시뮬레이션", "고정소수점 연산"],
        "usedIn": ["모든 게임", "RTS (스타크래프트)", "MOBA (LoL)", "격투 게임"],
        "determinism": {
          "title": "결정론적 시뮬레이션",
          "why": {
            "title": "왜 결정론이 필요한가?",
            "description": "락스텝 네트워킹에서는 모든 클라이언트가 동일한 입력을 받아 동일한 결과를 계산해야 합니다. 한 비트라도 차이가 나면 시간이 지남에 따라 게임 상태가 완전히 달라집니다.",
            "benefits": [
              "입력만 전송하면 되므로 대역폭 절약",
              "리플레이 시스템 구현 용이 (입력 시퀀스만 저장)",
              "수백 개의 유닛도 완벽하게 동기화 가능",
              "치팅 감지 가능 (시뮬레이션 결과 비교)"
            ]
          },
          "causes": {
            "title": "비결정성의 원인",
            "items": [
              {
                "name": "부동소수점 연산",
                "description": "IEEE 754 표준에도 불구하고, CPU/GPU 아키텍처, 컴파일러 최적화, FPU 설정에 따라 미세한 차이 발생",
                "example": "x86 vs ARM, -ffast-math 옵션, 80비트 확장 정밀도"
              },
              {
                "name": "정렬되지 않은 컨테이너",
                "description": "HashMap, HashSet 등의 순회 순서가 플랫폼마다 다름",
                "example": "엔티티 업데이트 순서가 달라지면 충돌 처리 결과가 달라짐"
              },
              {
                "name": "난수 생성",
                "description": "시스템 난수 생성기는 플랫폼마다 다른 시퀀스 생성",
                "example": "Math.random(), /dev/urandom"
              },
              {
                "name": "시간 기반 로직",
                "description": "System.currentTimeMillis(), Date.now() 등은 각 기기마다 다름",
                "example": "스폰 타이밍, 쿨다운 계산"
              },
              {
                "name": "초기화되지 않은 메모리",
                "description": "C/C++에서 초기화되지 않은 변수는 예측 불가능한 값을 가짐",
                "example": "스택 변수, malloc 반환값"
              },
              {
                "name": "멀티스레딩",
                "description": "스레드 실행 순서가 OS 스케줄러에 따라 달라짐",
                "example": "물리 업데이트와 AI 업데이트의 경쟁 조건"
              }
            ]
          },
          "methodologies": {
            "title": "결정론 달성 방법",
            "items": [
              {
                "name": "고정소수점 연산 (Fixed-Point)",
                "description": "부동소수점 대신 정수 기반 고정소수점 사용. 완전히 결정적이지만 구현이 복잡하고 정밀도 제한이 있음.",
                "usedIn": "스타크래프트, 에이지 오브 엠파이어, 팩토리오",
                "example": "Q16.16 형식: 상위 16비트는 정수, 하위 16비트는 소수"
              },
              {
                "name": "Soft Float 라이브러리",
                "description": "하드웨어 FPU 대신 소프트웨어로 부동소수점 연산을 에뮬레이션. 느리지만 크로스플랫폼에서 동일한 결과 보장.",
                "usedIn": "일부 모바일 게임, 에뮬레이터",
                "example": "Berkeley SoftFloat, libfixmath"
              },
              {
                "name": "결정론적 난수 생성기",
                "description": "동일한 시드에서 동일한 시퀀스를 생성하는 PRNG 사용",
                "usedIn": "모든 락스텝 게임",
                "example": "Xorshift, PCG, Mersenne Twister (시드 고정)"
              },
              {
                "name": "정렬된 컨테이너",
                "description": "HashMap 대신 TreeMap, 순회 전 정렬, 삽입 순서 보존 컨테이너 사용",
                "usedIn": "모든 락스텝 게임",
                "example": "LinkedHashMap, sorted iteration"
              },
              {
                "name": "틱 기반 시뮬레이션",
                "description": "실제 시간 대신 논리적 틱 카운터 사용. delta time 대신 고정 시간 간격으로 업데이트.",
                "usedIn": "RTS, 격투 게임, 시뮬레이션",
                "example": "16ms/tick (60Hz), 프레임 번호로 타이밍 계산"
              },
              {
                "name": "단일 스레드 시뮬레이션",
                "description": "게임 로직은 단일 스레드에서 실행하여 경쟁 조건 방지. 렌더링만 별도 스레드.",
                "usedIn": "대부분의 락스텝 게임",
                "example": "게임 로직 스레드 + 렌더링 스레드 분리"
              }
            ]
          },
          "testing": {
            "title": "결정론 검증",
            "description": "결정론적 시뮬레이션을 검증하는 방법들",
            "items": [
              "체크섬 비교: 매 틱마다 게임 상태의 해시를 계산하여 모든 클라이언트가 동일한지 확인",
              "리플레이 검증: 같은 입력 시퀀스로 여러 번 실행해서 동일한 결과가 나오는지 확인",
              "크로스 플랫폼 테스트: Windows, Mac, Linux, 다양한 CPU에서 동일한 결과 확인",
              "장시간 테스트: 미세한 차이가 누적되므로 긴 게임에서 동기화 유지 확인"
            ]
          },
          "caseStudies": {
            "title": "관련 사례 연구",
            "items": [
              {
                "gameId": "starcraft",
                "title": "스타크래프트",
                "description": "고정소수점 연산과 락스텝으로 수백 유닛의 완벽한 동기화 달성"
              },
              {
                "gameId": "lol",
                "title": "리그 오브 레전드",
                "description": "서버 권위 모델이지만 리플레이를 위해 결정론적 시뮬레이션 사용"
              }
            ]
          },
          "references": {
            "title": "참고 자료",
            "items": [
              {
                "title": "Gaffer On Games: Deterministic Lockstep",
                "url": "https://gafferongames.com/post/deterministic_lockstep/",
                "description": "락스텝 네트워킹의 기초와 결정론적 시뮬레이션 구현"
              },
              {
                "title": "Forrestthewoods: Synchronous RTS Engines and a Tale of Desyncs",
                "url": "https://www.forrestthewoods.com/blog/synchronous_rts_engines_and_a_tale_of_desyncs/",
                "description": "RTS 게임에서의 디싱크 문제와 해결 방법"
              },
              {
                "title": "Factorio Friday Facts #302: The Oil Changes",
                "url": "https://factorio.com/blog/post/fff-302",
                "description": "팩토리오의 부동소수점 결정론 문제 해결 사례"
              },
              {
                "title": "Age of Empires Multiplayer Architecture",
                "url": "https://www.gamedeveloper.com/programming/1500-archers-on-a-28-8-network-programming-in-age-of-empires",
                "description": "에이지 오브 엠파이어의 네트워킹 아키텍처 (1500 궁수)"
              },
              {
                "title": "Floating Point Determinism",
                "url": "https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/",
                "description": "부동소수점 결정론에 대한 심층 분석"
              },
              {
                "title": "GGPO: Fighting Game Networking",
                "url": "http://ggpo.net/",
                "description": "격투 게임을 위한 롤백 넷코드 라이브러리"
              }
            ]
          }
        }
      },
      "serialization": {
        "title": "직렬화 & 상태관리",
        "description": "데이터 저장, 전송, 복원",
        "concepts": ["JSON", "MessagePack", "Protocol Buffers", "압축", "상태 스냅샷"],
        "usedIn": ["저장/로드", "네트워크 전송", "리플레이"]
      },
      "rendering": {
        "title": "렌더링 & 시각화",
        "description": "게임 상태를 화면에 표현",
        "concepts": ["렌더링 파이프라인", "보간", "프레임 독립성", "LOD"],
        "usedIn": ["모든 게임"]
      },
      "physics": {
        "title": "물리 연산",
        "description": "충돌, 중력, 힘의 계산",
        "concepts": ["충돌 감지", "강체 역학", "Raycast", "트리거"],
        "usedIn": ["플랫포머", "FPS", "레이싱"]
      },
      "networking": {
        "title": "네트워크 통신 기초",
        "description": "TCP/UDP, 패킷, 지연시간",
        "concepts": ["TCP vs UDP", "지연시간", "패킷 손실", "대역폭"],
        "usedIn": ["멀티플레이어 게임"]
      }
    },
    "decisions": {
      "decisions-center": {
        "title": "설계 선택지",
        "description": "주제를 선택하세요"
      },
      "multiplayer-arch": {
        "title": "멀티플레이 아키텍처",
        "description": "P2P vs Client-Server, 권한 모델",
        "considerations": ["플레이어 수", "치트 민감도", "예산", "지연시간 요구사항"],
        "options": {
          "p2p": {
            "name": "P2P (Peer-to-Peer)",
            "pros": ["서버 비용 없음", "낮은 지연시간 가능"],
            "cons": ["치트 취약", "NAT 문제", "확장성 제한"],
            "useCases": ["격투 게임", "소규모 협동"]
          },
          "client-server": {
            "name": "Client-Server",
            "pros": ["서버 권한으로 치트 방지", "확장성", "중앙 제어"],
            "cons": ["서버 비용", "지연시간 증가"],
            "useCases": ["FPS", "MMORPG", "배틀로얄"]
          }
        },
        "caseStudies": {
          "title": "아키텍처 전환 사례",
          "items": [
            {
              "title": "워크래프트3 vs 리그 오브 레전드: 아키텍처 비교",
              "gameId": "lol",
              "problem": "LoL은 워크래프트3 유즈맵(DotA)에서 파생되었지만, 네트워킹 아키텍처는 완전히 다릅니다. 왜 이런 결정을 했을까요?",
              "decision": "워크래프트3/스타크래프트는 P2P 락스텝(한 플레이어가 호스트)을 사용합니다. 모든 클라이언트가 동일한 결정론적 시뮬레이션을 실행하고 입력만 전송합니다. 과거 네트워크 대역폭이 제한적이었기 때문입니다. 반면 LoL은 Riot의 전용 서버가 게임 상태를 계산하는 Client-Server 모델을 선택했습니다. 서버가 단일 진실 공급원이 되어 치팅을 방지합니다.",
              "result": "LoL은 대역폭이 충분해진 환경에서 치팅 방지와 확장성을 확보. 전용 서버 인프라로 안정적인 경쟁 환경 제공.",
              "demoPath": "/demo/lockstep"
            },
            {
              "title": "DotA → Dota 2: P2P에서 Client-Server로",
              "gameId": "dota2",
              "problem": "DotA 1은 워크래프트3 엔진의 P2P 락스텝을 그대로 사용했습니다.",
              "decision": "Dota 2는 Valve의 Source 2 엔진으로 재작성되며 클라이언트-서버 모델로 전환했습니다. 이는 LoL과 동일한 이유: 치팅 방지 + 전용 서버 인프라.",
              "result": "치팅 방지, 안정적인 e스포츠 환경, 매치메이킹 시스템 개선.",
              "demoPath": "/demo/lockstep"
            },
            {
              "title": "스타크래프트: P2P 락스텝의 이유",
              "gameId": "starcraft",
              "problem": "많은 게임들이 Client-Server로 전환하는데 스타크래프트는 왜 P2P를 유지할까요?",
              "decision": "P2P 락스텝 유지. 수천 유닛 상태를 매 프레임 전송하는 것은 불가능했던 1998년 환경에서 설계됨. 입력만 전송하여 대역폭 절약. TCP 사용으로 끊김보다 렉을 선호.",
              "result": "낮은 대역폭 요구사항, 완벽한 동기화, 리플레이 시스템 지원. 다만 호스트 이탈 시 새 호스트 선출 필요.",
              "demoPath": "/demo/lockstep"
            }
          ]
        },
        "references": {
          "title": "참고 자료",
          "items": [
            {
              "title": "How does the networking of Warcraft 3 work?",
              "url": "https://www.gamedev.net/forums/topic/331938-how-does-the-networking-of-warcraft-3-work/3165375/",
              "description": "워크래프트3의 P2P 네트워킹 구조"
            },
            {
              "title": "Game Networking Demystified, Part VI: Game Genres and FAQ",
              "url": "https://ruoyusun.com/2019/09/30/game-networking-6.html",
              "description": "장르별 게임 네트워킹 아키텍처 분석"
            },
            {
              "title": "Don't use Lockstep in RTS games",
              "url": "https://medium.com/@treeform/dont-use-lockstep-in-rts-games-b40f3dd6fddb",
              "description": "락스텝의 한계와 대안"
            },
            {
              "title": "Fixing the Internet for Real Time Applications: Part II",
              "url": "https://technology.riotgames.com/news/fixing-internet-real-time-applications-part-ii",
              "description": "Riot Games의 네트워크 최적화"
            },
            {
              "title": "1500 Archers on a 28.8: Network Programming in Age of Empires",
              "url": "https://www.gamedeveloper.com/programming/1500-archers-on-a-28-8-network-programming-in-age-of-empires",
              "description": "에이지 오브 엠파이어의 네트워킹 아키텍처"
            }
          ]
        }
      },
      "physics-authority": {
        "title": "물리 처리 방식",
        "description": "서버 vs 클라이언트 물리 연산",
        "considerations": ["반응성 요구사항", "경쟁성", "서버 리소스"],
        "options": {
          "server": {
            "name": "서버 물리",
            "pros": ["일관성 보장", "치트 방지"],
            "cons": ["입력 지연", "서버 부하"],
            "useCases": ["경쟁 게임", "e스포츠"]
          },
          "client": {
            "name": "클라이언트 물리",
            "pros": ["즉각적 반응", "서버 부하 감소"],
            "cons": ["동기화 문제", "치트 가능"],
            "useCases": ["싱글플레이어", "협동 PvE"]
          }
        },
        "caseStudies": {
          "title": "의사결정 사례 연구",
          "items": [
            {
              "title": "카운터스트라이크: Lag Compensation과 'Peeker's Advantage'",
              "gameId": "counter-strike",
              "problem": "CS에서 모서리를 돌아 적을 먼저 보는 플레이어(피커)가 유리합니다. 피커의 화면에서는 적이 보이지만, 적의 화면에서는 아직 피커가 나타나지 않은 상태입니다. 이것이 'Peeker's Advantage'입니다. 순수 서버 권한 모델에서는 빠른 움직임의 플레이어가 항상 불리해집니다.",
              "decision": "Valve는 'Lag Compensation' 시스템을 구현했습니다. 서버가 과거의 히트박스 위치를 저장하고, 클라이언트가 발사한 시점의 서버 상태로 되감아 히트 판정을 수행합니다. 이렇게 하면 클라이언트의 화면에서 맞춘 샷이 실제로 히트로 인정됩니다.",
              "result": "'Favor the Shooter' 원칙으로 사격자의 조준이 더 정확하게 반영됨. 다만 피격자 입장에서는 '이미 숨었는데 맞았다'는 느낌이 발생. cl_interp_ratio 등 클라이언트 설정으로 보간 버퍼를 조절하여 트레이드오프 조정 가능."
            },
            {
              "title": "오버워치: 'Favor the Shooter'와 하이브리드 접근",
              "gameId": "overwatch",
              "problem": "오버워치는 다양한 영웅이 존재하고, 트레이서 같은 빠른 영웅과 위도우메이커 같은 저격수가 공존합니다. 순수 서버 권한에서는 고핑 플레이어가 빠른 영웅을 맞추기 어렵고, 순수 클라이언트 권한에서는 치트와 불공정이 발생합니다.",
              "decision": "Blizzard는 'Favor the Shooter' 정책을 채택했습니다. 공격자의 클라이언트에서 맞은 것으로 판정되면 서버가 이를 존중합니다. 단, 방어 스킬(겐지 튕기기, D.Va 매트릭스)은 서버에서 우선 처리하여 '이미 막았는데 맞았다'를 방지.",
              "result": "공격자의 에임이 정확히 반영되어 쾌적한 공격 경험 제공. 방어 스킬의 신뢰성 유지. 다만 피격자의 '억울한 죽음' 체감은 존재. GDC 2017에서 이 시스템을 상세히 공개."
            },
            {
              "title": "포트나이트: 건축과 총격의 충돌",
              "gameId": "fortnite",
              "problem": "포트나이트는 총격 + 건축이 결합된 독특한 게임입니다. 플레이어가 벽을 세우는 동시에 적이 발사하면, 누가 먼저인지에 따라 결과가 달라집니다. 건축과 총격의 권한 충돌이 발생합니다.",
              "decision": "에픽게임즈는 서버 권한을 기반으로 하되, 클라이언트 예측으로 즉각적인 건축 피드백을 제공합니다. 총알은 서버에서 판정하지만, 벽 건설은 클라이언트에서 즉시 표시됩니다. 충돌 시 서버가 최종 결정.",
              "result": "건축의 반응성을 유지하면서 총격의 공정성 확보. 다만 높은 핑에서는 '벽을 세웠는데 뚫렸다'는 불만 발생. 이를 완화하기 위해 벽 건설에 짧은 우선권 부여."
            }
          ]
        },
        "references": {
          "title": "참고 자료",
          "items": [
            {
              "title": "Valve Developer: Source Multiplayer Networking",
              "url": "https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking",
              "description": "소스 엔진의 Lag Compensation 구현"
            },
            {
              "title": "Overwatch Gameplay Architecture and Netcode (GDC 2017)",
              "url": "https://www.youtube.com/watch?v=W3aieHjyNvw",
              "description": "오버워치의 Favor the Shooter 정책"
            },
            {
              "title": "Battle(non)sense: How Do Bullets Work in Games?",
              "url": "https://www.youtube.com/watch?v=hiHP0N-jMx8",
              "description": "다양한 게임의 히트 판정 비교"
            },
            {
              "title": "3kliksphilip: Peeker's Advantage Explained",
              "url": "https://www.youtube.com/watch?v=3JaCcsmjYM8",
              "description": "CS에서의 Peeker's Advantage 분석"
            },
            {
              "title": "Fortnite Server Performance Update",
              "url": "https://www.epicgames.com/fortnite/en-US/news/postmortem-of-service-outage-4-12",
              "description": "포트나이트의 서버 아키텍처"
            }
          ]
        }
      },
      "sync-strategy": {
        "title": "동기화 전략",
        "description": "낙관적 vs 비관적, 롤백",
        "considerations": ["게임 템포", "허용 가능한 지연시간", "복잡도 예산"],
        "options": {
          "optimistic": {
            "name": "낙관적 동기화",
            "pros": ["즉각적 피드백", "좋은 UX"],
            "cons": ["롤백 필요", "복잡한 구현"],
            "useCases": ["액션 게임", "FPS"]
          },
          "pessimistic": {
            "name": "비관적 동기화",
            "pros": ["단순한 구현", "일관성 보장"],
            "cons": ["입력 지연", "느린 반응"],
            "useCases": ["턴제 게임", "RTS"]
          }
        },
        "caseStudies": {
          "title": "의사결정 사례 연구",
          "items": [
            {
              "title": "철권 7 → 철권 8: 지연 기반에서 롤백으로",
              "gameId": "tekken",
              "problem": "철권 7의 지연 기반 넷코드는 5-20프레임의 입력 지연을 발생시켜 온라인 대전의 반응성이 크게 떨어졌습니다. 스트리트 파이터 5, 길티기어 등 경쟁작들이 롤백을 채택하면서 비교 대상이 되었습니다.",
              "decision": "철권 8에서 롤백 넷코드로 전환. 3D 격투 게임은 캐릭터당 155개 이상의 기술과 복잡한 애니메이션으로 롤백 구현이 어렵지만, 개발팀이 이를 감수.",
              "result": "로컬 입력 반응성 대폭 개선. 크로스플랫폼 대전 지원. SF6보다는 약간 떨어지지만 '99%의 매치에서 부드러운 경험' 제공.",
              "demoPath": "/demo/lockstep"
            },
            {
              "title": "왜 스타크래프트는 락스텝을 유지할까?",
              "gameId": "starcraft",
              "problem": "격투 게임들이 롤백으로 전환하는 추세에서 스타크래프트는 여전히 지연 기반 락스텝을 사용합니다.",
              "decision": "락스텝 유지. 1) 한 경기에 수백 개의 유닛이 존재하여 롤백 시 모든 유닛 상태를 저장하고 재시뮬레이션하는 것은 메모리와 CPU 부담이 큼. 2) RTS는 격투 게임만큼 프레임 단위 정밀 입력이 필요하지 않아 2-4프레임 지연은 수용 가능. 3) 결정론적 시뮬레이션이 잘 작동하고 있으며 리플레이 시스템도 이에 의존.",
              "result": "안정적인 동기화 유지, 리플레이 시스템 보존, 레거시 시스템과의 호환성 유지.",
              "demoPath": "/demo/lockstep"
            },
            {
              "title": "왜 LoL은 클라이언트 예측을 기본으로 하지 않을까?",
              "gameId": "lol",
              "problem": "FPS 게임들은 클라이언트 예측으로 즉각적인 반응성을 제공하는데, LoL은 왜 서버 응답을 기다릴까요?",
              "decision": "서버 권위 우선. 1) 서버가 유일한 진실 공급원이면 클라이언트 조작이 어려워 경쟁 게임에서 공정성 보장. 2) 10명의 챔피언, 미니언, 스킬샷이 복잡하게 상호작용하여 클라이언트 예측이 틀리면 '순간이동' 현상이 빈번해짐. 3) Riot Direct 네트워크로 60ms 이하 핑을 보장하여 저지연 환경에서는 예측의 이점이 크지 않음.",
              "result": "치팅 방지, 일관된 게임 경험, 안정적인 경쟁 환경 제공.",
              "demoPath": "/demo/lockstep"
            }
          ]
        },
        "references": {
          "title": "참고 자료",
          "items": [
            {
              "title": "Netcode Concepts Part 3: Lockstep and Rollback",
              "url": "https://meseta.medium.com/netcode-concepts-part-3-lockstep-and-rollback-f70e9297271",
              "description": "락스텝과 롤백 넷코드의 개념과 비교"
            },
            {
              "title": "Netcode Architectures Part 2: Rollback",
              "url": "https://www.snapnet.dev/blog/netcode-architectures-part-2-rollback/",
              "description": "롤백 넷코드 아키텍처 심층 분석"
            },
            {
              "title": "GGPO - Wikipedia",
              "url": "https://en.wikipedia.org/wiki/GGPO",
              "description": "격투 게임을 위한 롤백 넷코드 라이브러리"
            },
            {
              "title": "Client-Side Prediction and Server Reconciliation",
              "url": "https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html",
              "description": "클라이언트 예측과 서버 조정 기법"
            },
            {
              "title": "Tekken 8 Rollback Netcode – All you need to know",
              "url": "https://esports.gg/news/tekken-8/tekken-8-rollback-netcode/",
              "description": "철권 8의 롤백 넷코드 구현"
            },
            {
              "title": "Determinism in League of Legends: Introduction",
              "url": "https://technology.riotgames.com/news/determinism-league-legends-introduction",
              "description": "LoL의 결정론적 시뮬레이션"
            }
          ]
        }
      },
      "tickrate": {
        "title": "틱레이트 & 보간",
        "description": "업데이트 주기와 부드러운 표현",
        "considerations": ["게임 장르", "정밀도 요구사항", "인프라 비용"],
        "options": {
          "high": {
            "name": "높은 틱레이트 (60-128Hz)",
            "pros": ["정밀한 히트박스", "부드러운 움직임"],
            "cons": ["높은 대역폭", "서버 부하"],
            "useCases": ["FPS", "격투 게임"]
          },
          "low": {
            "name": "낮은 틱레이트 (10-30Hz)",
            "pros": ["낮은 대역폭", "서버 비용 절감"],
            "cons": ["보간 필요", "정밀도 감소"],
            "useCases": ["MMORPG", "전략 게임"]
          }
        },
        "caseStudies": {
          "title": "의사결정 사례 연구",
          "items": [
            {
              "title": "CS:GO → CS2: 64Hz vs 128Hz 논쟁과 서브틱 해결책",
              "gameId": "counter-strike",
              "problem": "CS:GO 공식 매치메이킹은 64Hz 서버를 사용했지만, 프로와 열성 팬들은 128Hz를 요구했습니다. 64Hz에서는 빠른 움직임이나 정밀한 에임에서 '샷이 안 맞는' 느낌이 발생했습니다. FACEIT/ESEA 등 서드파티 서비스는 128Hz를 제공하여 차이가 두드러졌습니다.",
              "decision": "CS2에서 '서브틱(Sub-tick)' 시스템 도입. 틱레이트에 관계없이 서버가 틱 사이의 정확한 입력 타이밍을 알 수 있게 됨. 클라이언트가 틱 내 정확한 시간을 함께 전송하여 128Hz의 정밀도를 64Hz 대역폭으로 달성.",
              "result": "64Hz 서버에서도 128Hz급 히트 판정 정밀도 제공. 서버 인프라 비용 절감 + 경쟁 공정성 확보. 다만 일부 고수준 플레이어들은 여전히 128Hz의 부드러움을 선호."
            },
            {
              "title": "포트나이트: 20Hz에서 30Hz로, 그리고 Replication Graph",
              "gameId": "fortnite",
              "problem": "초기 포트나이트는 20Hz 서버 틱레이트로 운영되었습니다. 100명 플레이어의 건물/총격/이동을 모두 동기화하려니 대역폭과 서버 부하가 심했습니다. 플레이어들은 '총알이 휘어간다', '벽을 세웠는데 뚫린다' 등의 불만을 제기했습니다.",
              "decision": "틱레이트를 30Hz로 증가시키고, 'Replication Graph' 시스템을 도입. 각 클라이언트에게 관련 있는 데이터만 선별적으로 전송하여 대역폭 최적화. 가까운 적은 더 자주, 먼 적은 덜 자주 업데이트.",
              "result": "히트 판정과 건축 반응성 개선. 100명 동시 플레이에서도 안정적인 게임플레이 제공. 에픽게임즈는 이 시스템을 Unreal Engine에 통합하여 다른 대규모 멀티플레이어 게임에서도 활용 가능."
            },
            {
              "title": "발로란트 vs 오버워치: 128Hz로 경쟁 우위 확보",
              "gameId": "overwatch",
              "problem": "오버워치는 63Hz 서버 틱레이트를 사용했습니다. 경쟁 FPS 시장에서 이는 논란이 되었고, 특히 히트스캔 영웅(위도우메이커, 맥크리)의 히트 판정에서 불만이 많았습니다.",
              "decision": "발로란트는 출시부터 128Hz 서버를 제공하며 이를 핵심 마케팅 포인트로 삼았습니다. 오버워치 2에서 Blizzard는 일부 경쟁전 모드에서 틱레이트를 높이는 실험을 진행했지만, 기본 틱레이트는 유지했습니다.",
              "result": "발로란트가 경쟁 FPS 시장에서 '넷코드가 좋다'는 평판을 확보. 틱레이트가 게임 선택의 중요 요소가 됨을 증명. 인프라 비용 vs 경쟁력 트레이드오프의 대표 사례."
            }
          ]
        },
        "references": {
          "title": "참고 자료",
          "items": [
            {
              "title": "CS2's Sub-Tick System Explained",
              "url": "https://www.youtube.com/watch?v=vdLRLO3bdm0",
              "description": "CS2 서브틱 시스템의 작동 원리"
            },
            {
              "title": "Battle(non)sense: Fortnite Netcode Analysis",
              "url": "https://www.youtube.com/watch?v=W5lUCeAu_2k",
              "description": "포트나이트의 틱레이트와 히트 판정 분석"
            },
            {
              "title": "Epic Games: Replication Graph Overview",
              "url": "https://docs.unrealengine.com/en-US/Gameplay/Networking/ReplicationGraph/",
              "description": "언리얼 엔진의 Replication Graph 시스템"
            },
            {
              "title": "Valorant's 128-Tick Servers",
              "url": "https://technology.riotgames.com/news/valorants-128-tick-servers",
              "description": "발로란트의 128Hz 서버 아키텍처"
            },
            {
              "title": "CS:GO 64 vs 128 Tick - The Debate",
              "url": "https://www.reddit.com/r/GlobalOffensive/comments/4y62o5/csgo_128_tick_vs_64_tick/",
              "description": "커뮤니티의 64Hz vs 128Hz 논쟁"
            },
            {
              "title": "Overwatch Netcode Analysis",
              "url": "https://www.youtube.com/watch?v=vHO6Ky-w0UQ",
              "description": "오버워치의 넷코드와 틱레이트 분석"
            }
          ]
        }
      },
      "balancing": {
        "title": "밸런싱 구조",
        "description": "데이터 드리븐 밸런싱 설계",
        "considerations": ["팀 구성", "업데이트 빈도", "운영 계획"],
        "options": {
          "hardcoded": {
            "name": "하드코딩",
            "pros": ["빠른 개발", "단순함"],
            "cons": ["패치 필요", "유연성 부족"],
            "useCases": ["소규모 프로젝트", "프로토타입"]
          },
          "data-driven": {
            "name": "데이터 드리븐",
            "pros": ["핫픽스 가능", "기획자 접근성", "A/B 테스트"],
            "cons": ["초기 설정 복잡", "런타임 오버헤드"],
            "useCases": ["라이브 서비스", "대규모 게임"]
          }
        }
      }
    },
    "ui": {
      "backToHome": "돌아가기",
      "caseStudy": "사례 연구",
      "fundamental": "기본 원리",
      "designDecision": "설계 결정",
      "gameInfo": "게임 정보",
      "genre": "장르",
      "releaseYear": "출시",
      "keyFeatures": "핵심 특징",
      "relatedFundamentals": "관련 기본 원리",
      "relatedDecisions": "관련 설계 결정",
      "coreConcepts": "핵심 개념",
      "usedIn": "활용 분야",
      "runDemo": "데모 실행하기",
      "contentComingSoon": "콘텐츠 준비 중",
      "contentComingSoonDesc": "이 페이지의 상세 내용이 곧 추가될 예정입니다.",
      "detailedContentComingSoon": "상세 콘텐츠 준비 중",
      "detailedContentComingSoonDesc": "더 자세한 설명과 예제가 곧 추가될 예정입니다.",
      "theorySection": "이론 설명",
      "visualizationSection": "시각화",
      "visualizationDemoSection": "시각화 / 데모",
      "theoryPlaceholder": "이론 설명 영역",
      "visualizationPlaceholder": "시각화 영역",
      "considerations": "결정 시 고려사항",
      "pros": "장점",
      "cons": "단점",
      "useCases": "사용 사례",
      "pageNotFound": "페이지를 찾을 수 없습니다",
      "goHome": "홈으로 돌아가기",
      "graphView": "그래프",
      "bookView": "목차",
      "back": "뒤로",
      "demo": "데모",
      "view": "보기",
      "benefits": "장점",
      "example": "예시",
      "usedInGames": "사용된 게임",
      "viewCaseStudy": "사례 보기",
      "learnMore": "자세히 보기",
      "decisionCaseStudies": "의사결정 사례 연구",
      "references": "참고 자료",
      "problem": "문제",
      "decision": "결정",
      "result": "결과",
      "viewDemo": "데모 보기",
      "relatedCaseStudy": "관련 사례"
    }
  }
}
